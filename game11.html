<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mexico mais sans lapin et sans mouvement ðŸ’£</title>
    <style>
        /* General body styling */
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #ffebcd;
            background-image: url('https://www.transparenttextures.com/patterns/snow.png');
            margin: 0;
        }

        /* Christmas themed title */
        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #d32f2f;
            font-family: 'Comic Sans MS', cursive;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* User status */
        #userStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.2em;
            color: #a23636;
        }

        /* Instructions section */
        #instructions {
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
            text-align: center;
            max-width: 1000px;
            font-size: 1.2em;
            color: #333;
            overflow-y: auto;  /* Added for scrolling if needed */
            max-height: 400px; /* Set a maximum height */
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(10, 30px);
            gap: 2px;
            justify-content: center;
            margin-top: 20px;
        }

        .cell {
            width: 30px;
            height: 30px;
            text-align: center;
            line-height: 30px;
            border: 1px solid #ccc;
            background-color: #e0e0e0;
            cursor: pointer;
        }

        .cell.revealed {
            background-color: #7a6f6f;
        }

        .cell.flagged {
            background-color: #ffcc00;
        }

        .cell.mine {
            background-color: red;
        }

        .cell.number {
            font-weight: bold;
        }

        .status {
            margin-top: 20px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }

        .btn:hover {
            background-color: #45a049;
        }

        #timer {
            font-size: 20px;
            margin-top: 10px;
        }

        #score {
            font-size: 20px;
            margin-left: 20px;
        }

        .decoration {
    position: relative; /* Change to relative */
    display: flex; /* Use flexbox for centering */
    justify-content: center; /* Horizontally center */
    align-items: center; /* Vertically center */
    height: 100vh; /* Full viewport height to center */
    padding: 20px 0;
}

#santa {
    height: 400px;
    width: auto;
}
    </style>
</head>
<body>

    <h1>ðŸ’£Mexico mais sans lapin et sans mouvement ðŸ’£</h1>

    <div id="instructions">
        <p>La magie de la ceinture de NoÃ«l faisait son effet : nos camarades, malgrÃ© leurs diffÃ©rences dâ€™Ã¢ge, de poils ou de tempÃ©rament, Ã©taient devenus des alliÃ©s complices. Mais alors quâ€™ils se laissaient emporter par ce moment de fraternitÃ©, un claquement sonore fit trembler le sol sous leurs pieds. En un instant, une nouvelle trappe sâ€™ouvrit, les aspirant dans un tourbillon chaotique avant de les dÃ©poser dans une piÃ¨ce Ã©trangement familiÃ¨re.  </p>
 <p>Une moquette au sol, des murs ornÃ©s dâ€™Ã©tagÃ¨res bourrÃ©es de livres, un lit couvert de papiers griffonnÃ©s dâ€™une fine Ã©criture et, au fond de la piÃ¨ce, un vieil ordinateur qui semblait prendre une Ã©ternitÃ© Ã  sâ€™allumer. Un tiroir laissait entrevoir un trÃ©sor : un paquet de bonbons arlequins. BÃ©bÃ© Romain ne put retenir une larme de nostalgie en reconnaissant cet endroit oÃ¹, chaque midi, il regardait les rÃ©sumÃ©s de Ligue 1. Topapa, lui, se revoyait en train dâ€™Ã©craser tous les scores sur jeuxdesport.com, les yeux rivÃ©s sur cet Ã©cran.  </p>
 <p>Â« Je le savais, Â» sâ€™exclama BÃ©bÃ© Romain avec excitation, Â« notre codeur a dÃ» nous prÃ©parer un banger comme Mexico ! Â»  </p>
 <p>GrinchÃ©mie, en entendant Ã§a, Ã©tira ses lÃ¨vres de scepticisme Ã  la maniÃ¨re dâ€™un fameux meme, imaginant bien le codeur, en sueur la veille du 1er dÃ©cembre,  tentant dÃ©sespÃ©rÃ©ment de bidouiller quelque chose qui pourrait rappeler ce grand classique avec ses maigres notions de HTML.  </p>
 <p>Sans attendre, tous se ruÃ¨rent vers la chaise devant lâ€™ordinateur, mais RaseToiLaMoustache, dâ€™une agilitÃ© surprenante, avait dÃ©jÃ  prÃ©shot la place et appuyait sur le bouton dâ€™allumage. Le logo Windows s'afficha Ã  l'Ã©cran, entamant sa 80áµ‰ rotation de chargement, chaque rotation semblant ralentir encore davantage.  </p>
 <p>Pendant ce suspense interminable, les anges de NoÃ«l firent leur apparition, portant des plateaux remplis de victuailles : des verres de jus dâ€™orange pressÃ©, des pÃ¢tisseries aux airs de chef-dâ€™Å“uvre, des lamelles de carottes et de poivrons crus, et des sou beureks grÃ©sillants. RaseToiLaMoustache, les yeux toujours fixÃ©s sur lâ€™Ã©cran, ne sâ€™aperÃ§ut mÃªme pas que les anges, bienveillants, le nourrissaient depuis plusieurs minutes Ã  la fourchette de morceaux de poire coupÃ©s  et quâ€™il les mÃ¢chaient par rÃ©flexe.   </p>
 <p>Â« Meueheahah ! Â» sâ€™exclama-t-il enfin.Au bout de ce qui semblait une Ã©ternitÃ©, le bureau Windows apparut enfin Ã  lâ€™Ã©cran. Topapa, traduit joyeusement : Â« Câ€™est un DÃ©mineur ! Â»  </p>
 <p>Â« Ah jâ€™aurais prÃ©fÃ©rÃ© un Mexico ou un nouveau Mario Party Â» dit BÃ©bÃ© Romain  </p>
 <p>Les yeux de Dudley brillÃ¨rent dâ€™excitation. Â« Un DÃ©mineur ? Mais de quelle taille ? La Russie ? Ou plutÃ´t Malte ? Â»  </p>
 <p>Explication du jeu : Il sâ€™agit dâ€™un dÃ©mineur. Un timer se lance aprÃ¨s avoir dÃ©couvert une case. Un clic droit permet aussi de mettre un drapeau. Il faut trouver 10 mines. Pour pimenter le jeu, quand on clique sur une cellule ne contenant pas de mines aux alentours, cela ne dÃ©bloque pas automatiquement toutes les cellules mitoyennes. Â« Comment Ã§a ? Je nâ€™ai rÃ©ussi Ã  coder Ã§a ? Â» Ok et bien je rajoute 5 mines de plus. VoilÃ . Ca je peux faire.   </p>
 <p>Votre score vaut (100- votre temps pour finir la grille).   </p>
 <p>Vous avez 10 essais pour amÃ©liorer votre score. Pour rejouer, pensez Ã  refresh refresh code PIN.  </p>
 <p>Impossible sur Smartphone
        </p>
    </div>
 <img id="santa" class="decoration" src="https://i.imgur.com/0Yg7mMk.jpeg" alt="Santa Claus">
    
    <div id="userStatus"></div>
    <div id="status" class="status"></div>
    <div id="timer">Temps: 0s</div>
    <div id="score">Score: 0</div>
    <div id="grid" class="grid"></div>
    <div id="highest-score">Meilleur score: 0</div>
    <div id="total-play-count">Jeux jouÃ©s: 0</div>

      <script defer type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, addDoc } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC4bjg7lVwd8FU8MREaPhBsBENv5qmiYYM",
            authDomain: "calendrier-de-l-avent-54e3a.firebaseapp.com",
            databaseURL: "https://calendrier-de-l-avent-54e3a-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "calendrier-de-l-avent-54e3a",
            storageBucket: "calendrier-de-l-avent-54e3a.appspot.com",
            messagingSenderId: "850639567855",
            appId: "1:850639567855:web:0d799a1ecca005fcff141a",
            measurementId: "G-PC1W7RYVEH"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
          
        let playCount = 0;
        let totalPlayCountGame11 = 0;
        let highestScore = 0;
          
        let userId = '';
        const gridSize = 10;
        const mineCount = 15;
        let grid = [];
        let mines = [];
        let revealedCount = 0;
        let gameOver = false;
        let timer = null;
        let startTime = 0;
        let score = 0;

        const gridContainer = document.getElementById('grid');
        const statusDiv = document.getElementById('status');
        const timerDisplay = document.getElementById('timer');
        const scoreDisplay = document.getElementById('score');
        const highestScoreDisplay = document.getElementById('highest-score');
        const totalPlayCountDisplay = document.getElementById('total-play-count');

         onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                document.getElementById('userStatus').innerText = `Bienvenue : ${user.email}`;

                const userRef = doc(db, 'users', userId);
                const docSnap = await getDoc(userRef);

                if (!docSnap.exists()) {
                    await setDoc(userRef, { userId: userId, totalPlayCountGame11: 0, highestScoreGame11: 0, UserEmail: user.email });
                } else {
                    const userData = docSnap.data();
                    totalPlayCountGame11 = userData.totalPlayCountGame11 || 0;
                    highestScore = userData.highestScoreGame11 || 0;
                    playCount = totalPlayCountGame11 + 1;
                    UserEmail: user.email
                    
                    highestScoreDisplay.innerText = `Meilleur score: ${highestScore}`;
                    totalPlayCountDisplay.innerText = `Jeux jouÃ©s: ${totalPlayCountGame11}`;
                    
                    
                }
            } else {
                window.location.href = 'login.html';
            }
        });

        // Initialize the game
        function initGame() {
            grid = [];
            revealedCount = 0;
            gameOver = false;
            gridContainer.innerHTML = '';
            mines = [];
            startTime = 0;
            score = 0;
            timerDisplay.textContent = "Temps: 0s";
            scoreDisplay.textContent = "Score: 0";

            // Generate grid cells
            for (let i = 0; i < gridSize; i++) {
                grid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('contextmenu', handleCellRightClick);
                    gridContainer.appendChild(cell);
                    grid[i][j] = { revealed: false, flagged: false, mine: false, adjacentMines: 0 };
                }
            }

            // Place mines randomly
            let minesPlaced = 0;
            while (minesPlaced < mineCount) {
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);
                if (!grid[row][col].mine) {
                    grid[row][col].mine = true;
                    mines.push({ row, col });
                    minesPlaced++;
                }
            }

            // Calculate adjacent mines for each cell
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (!grid[i][j].mine) {
                        let count = 0;
                        for (let x = -1; x <= 1; x++) {
                            for (let y = -1; y <= 1; y++) {
                                const newRow = i + x;
                                const newCol = j + y;
                                if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                                    if (grid[newRow][newCol].mine) {
                                        count++;
                                    }
                                }
                            }
                        }
                        grid[i][j].adjacentMines = count;
                    }
                }
            }

            // Update the status
            statusDiv.textContent = `Mines restantes: ${mineCount}`;
        }

        // Start timer
        function startTimer() {
            if (timer) return;  // Prevent multiple timers from running
            timer = setInterval(() => {
                startTime++;
                timerDisplay.textContent = `Temps: ${startTime}s`;
            }, 1000);
        }

        // Handle click event on a cell
        function handleCellClick(event) {
            if (gameOver) return;
            const row = event.target.dataset.row;
            const col = event.target.dataset.col;

            // Start the timer when the first click is made
            startTimer();

            // Reveal the clicked cell
            revealCell(row, col);
        }

        // Handle right-click event (flagging a cell)
        function handleCellRightClick(event) {
            event.preventDefault();
            if (gameOver) return;
            const row = event.target.dataset.row;
            const col = event.target.dataset.col;

            // Toggle flagging of the cell
            toggleFlag(row, col);
        }

        // Reveal a cell and its neighbors
        function revealCell(row, col) {
            if (grid[row][col].revealed || grid[row][col].flagged) return;

            grid[row][col].revealed = true;
            const cell = gridContainer.querySelector(`[data-row='${row}'][data-col='${col}']`);
            cell.classList.add('revealed');

            if (grid[row][col].mine) {
                cell.classList.add('mine');
                gameOver = true;
                score = 0;  // Score is 0 if the user hits a bomb
                statusDiv.textContent = "Game Over! Sale Noob!";
                saveScore(score)
                clearInterval(timer); // Stop timer
                revealAllMines();
            } else {
                if (grid[row][col].adjacentMines > 0) {
                    cell.textContent = grid[row][col].adjacentMines;
                    cell.classList.add('number');
                }

                revealedCount++;
                if (revealedCount === gridSize * gridSize - mineCount) {
                    gameOver = true;
                    score = Math.max(0, 100 - startTime);  // Score is calculated based on the time taken
                    saveScore(score)
                    statusDiv.textContent = "FÃ©licitations! Mais un peu lent!";
                    clearInterval(timer); // Stop timer
                }

                if (grid[row][col].adjacentMines === 0) {
                    // Chain reaction: reveal neighboring cells
                    for (let x = -1; x <= 1; x++) {
                        for (let y = -1; y <= 1; y++) {
                            const newRow = row + x;
                            const newCol = col + y;
                            // Check if the new cell is within bounds and hasn't been revealed
                            if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                                // Only reveal if it isn't already revealed or flagged
                                if (!grid[newRow][newCol].revealed && !grid[newRow][newCol].flagged) {
                                    revealCell(newRow, newCol);
                                }
                            }
                        }
                    }
                }
            }
            scoreDisplay.textContent = `Score: ${score}`;
        }

        // Flag or unflag a cell
        function toggleFlag(row, col) {
            const cell = gridContainer.querySelector(`[data-row='${row}'][data-col='${col}']`);
            if (grid[row][col].revealed) return;

            grid[row][col].flagged = !grid[row][col].flagged;
            cell.classList.toggle('flagged');
            cell.textContent = grid[row][col].flagged ? "ðŸš©" : "";
        }

        // Reveal all mines when game over
        function revealAllMines() {
            for (const mine of mines) {
                const mineCell = gridContainer.querySelector(`[data-row='${mine.row}'][data-col='${mine.col}']`);
                mineCell.classList.add('mine');
                mineCell.textContent = "ðŸ’£";
            }
        }

          async function saveScore(score) {
            try {
                const gameData = { score: score, playCount: playCount, timestamp: new Date() };
                await addDoc(collection(db, 'users', userId, 'Game11'), gameData);

                const userRef = doc(db, 'users', userId);


                await updateDoc(userRef, { totalPlayCountGame11: playCount });
                if (totalPlayCountGame11 <= 5 && score > highestScore) {
                    highestScore = score;
                    await updateDoc(userRef, { highestScoreGame11: highestScore });
                    highestScoreDisplay.innerText = `Meilleur score: ${highestScore}`; // Update display for highest score
                }
            } catch (error) {
                console.error("Error saving score:", error);
            }
        }

        // Start the game for the first time
        initGame();
    </script>
</body>
</html>
